# 11장 원시 값과 객체의 비교

자바스크립트는 크게 원시 타입과 객체 타입으로 구분할 수 있다.

1. 원시 타입의 값 - 변경 불가능한 값
2. 객체(참조) 타입의 값 - 변경 가능한 값
3. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값**이 저장된다.
4. 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값**이 저장된다.

### 값에 의한 전달 pass by value

원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값이 복사**되어 전달된다.

### 참조에 의한 전달 pass by reference

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사**되어 전달된다.

## 11.1 원시 값

원시 타입의 값, 원시 값은 변경 불가능한 값이다.
한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없다.

변수는 하나의 값을 저장하기 위한 메모리 공간, 그 공간을 식별하려고 붙인 이름이다.
값은 이 변수에 저장된 데이터이며, 표현식이 평가되어 생성된 결과이다.

```javascript
// 예를 들어 var i 는 변수이며, =이라는 표현식으로 평가되서 생성된 값은 10이다.
var i = 10;
```

변수는 값의 재할당이 가능하다.
기존에 원시 값을 할당한 변수에 새로운 원시 값을 할당하면 메모리 공간에 저장되어있던 값이 변경되는 것이 아니라 새로운 메모리 공간을 확보하고, 새로 할당된 원시 값을 저장한 후 새로 할당된 변수는 재할당된 원시 값을 가리킨다.
이 때 변수가 참조하고있던 메모리의 주소가 바뀐다.

값은 변경이 되지 않고 변수가 참조하고 있던 메모리 주소가 바뀌는 것, 이러한 특징이 값의 **불변성**이다.

불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 방법이 없다.

재할당 외에 원시 값이 변경된다면, 값의 변경 내역을 추적하기 어렵다.

문자열은 변경 불가능한 값이며, 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖는다.

```javascript
var str = "string";
str[0] = "S"; // 접근은 가능하나 문자열은 원시 값이므로 변경되지 않는다. 에러가 발생하지 않는다.
console.log(str); // 'string'
```

어떤 변수에 기존에 원시 값이 할당된 변수를 할당한다면, 기존의 원시 값이 복사되어 전달된다.
이를 **값에 의한 전달**이라고 한다.

```javascript
var num1 = 10;
var num2 = num1; // 기존 원시 값 복사
```

두 변수는 원시 값이 복사되었지만 각각 다른 메모리 값에 저장되어있는 서로 다른 별개의 값이다.
`num1` 변수의 값을 변경해도 `num2` 변수의 값에는 영향이 없다.

## 11.2 객체

객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다.
객체는 원시 값처럼 확보해야할 메모리 공간의 크기를 사전에 정해놓을 수 없다.

변수에 객체를 할당하게 되면, 해당 변수는 특정 메모리 공간의 참조 값을 가리키고, 해당 참조 값은 실제 객체가 저장되어있는 메모리 공간을 참조한다.

원시 값을 할당한 변수의 경우 `변수는 OO값을 갖는다.` 또는 `변수의 값은 OO이다.`라고 표현하지만,
객체 값을 할당한 변수의 경우 `변수는 객체를 참조한다.` 또는 `변수는 객체를 가리키고 있다.`라고 표현한다.

객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.

```javascript
// 객체 값은 삭제, 추가, 갱신이 가능하다.
var person = {
  name: "Lee",
};
person.name = "kim"; //갱신
person.city = "seoul"; //추가
```

객체는 원시 값과 다르게 여러 식별자가 하나의 객체를 공유할 수 있다. 원시 값은 깊은 복사를 한다.

#### 얕은 복사와 깊은 복사

```javascript
const obj = { x: { y: 1 } };

// 얕은 복사
const obj2 = { ...obj };
// 깊은 복사
const _ = require("lodash");
const ogj3 = _.cloneDeep(obj);

const num = 1;
// 깊은 복사
const num2 = num;
```

기존에 객체를 가리키던 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.
이것이 **참조에 의한 전달**이다.

저장된 변수의 메모리 주소는 다르지만, 각 변수가 가리키는 참조 값(객체를 가리키는 메모리 공간의 주소)은 동일하다.

```javascript
var person1 = { name: "이가은", city: "seoul" };
var person2 = person1; // 참조 값 복사 (얕은 복사)
console.log(person1 === person2); // false 변수의 메모리 주소가 다르다.
console.log(person1.name === person2.name); // true 변수가 가리키는 참조 값은 동일하다.
```
